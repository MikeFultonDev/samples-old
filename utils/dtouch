#!/bin/sh
#
# dtouch - allocate a dataset (VSAM, Sequential, PDS or PDSE)
#
#set -x
export ME=$0
function syntax {
  echo "${ME} [<options>] [<dataset name>]"
  echo " where <options> can be one or more of:"
  echo " -a [verbose allocation output]"
  echo " -v [verbose name output]"
  echo " -t<dataset type>"
  echo " -s<dataset primary size> (in bytes)"
  echo " -r<record format>"
  echo " -l<logical record length>"
  echo " -d<data class name> [required for SMS-managed datasets. All VSAM datasets are SMS-managed]"
  echo " -k<key offset>:<key length> [required for Keyed Sequential Datasets (KSDS)]"
  echo " <dataset type> may be one of: KSDS, ESDS, RRDS, SEQ, PDS, PDSE. Default is a PDSE"
  echo " <primary size> is the number of bytes to allocate for the dataset. Default is 5M."
  echo "   Size may include a suffix of K (kilobytes), M (megabytes), G (gigabytes)"
  echo " <record format> is one of FB, VB, U. Default is FB"
  echo " <logical record length> is expressed in bytes (for VB, this includes the prefix area). Default is 80 for FB, 137 for FB, 0 for U"
  echo " <dataset name> is the name of the dataset to allocate. If no dataset name is specified, a generated dataset name will be created." 
} 
  
function clean {
  str=$1
  str=`print ${str} | tr [:lower:] [:upper:]`
  print "${str##[=]}"
}

function tempname {
  count=$1
  hlq=`hlq`
  time=`date | awk ' { print $4; }' | awk -F':' '{ print "T"$1$2$3; }'`
  counter="RA${count}"
  process=`printf "P%7.7X" $$`
  echo "${hlq}.${time}.${counter}.${process}"
}

export INVALID=-1
function getNumber {
  str=$1
  case ${str} in
    (*[!0-9]*|'') value=${INVALID};;
    (*)           value=${str};;
  esac
  echo "${value}"
}

function normalizeSize {
  BYTES_PER_TRACK=56664
  multiplier=0
  value=0
  size=$1
  smsinfo=$2
  prefix=${size%[[:alpha:]]}
  suffix=`print -n ${size} | tail -c -1`
  case ${suffix} in
    (k|K) multiplier=1000;;
    (m|M) multiplier=1000000;;
    (g|G) multiplier=1000000000;;
    (*) return ${INVALID};;
  esac
  value=`getNumber ${prefix}`
  if [ ${value} -eq ${INVALID} ]; then
    echo ${INVALID};
  else
    if [[ "${smsinfo}" == "" ]]; then
      if [ ${multiplier} -gt 1000 ]; then
        tracks=`echo $((${value} * (${multiplier} / ${BYTES_PER_TRACK}) + 1 ))`
      else
        tracks=`echo $(( (${value} * ${multiplier}) / ${BYTES_PER_TRACK} + 1))`
      fi
      echo "SPACE(${tracks},${tracks}) TRACK"
    else 
      echo "SPACE(1,1) AVGREC(${suffix}) AVBLOCK(${value})"
    fi 
  fi
}

size="5M"
type="PDSE"
recfm="FB"
lrecl=""
name=""
key=""
keyoff=${INVALID}
keylen=${INVALID}
dataclass=""
verboseName=0
verboseAllocation=0

while getopts ":t:s:r:l:k:d:va" opt; do
  case ${opt} in
    t )
      type=`clean ${OPTARG}`
      ;;
    s )
      size=`clean ${OPTARG}`
      ;;
    r )
      recfm=`clean ${OPTARG}`
      ;;
    l )
      lrecl=`clean ${OPTARG}`
      ;;
    k )
      key=`clean ${OPTARG}`
      ;;
    d )
      dataclass=`clean ${OPTARG}`
      ;;
    v )
      verboseName=1
      ;;
    a )
      verboseAllocation=1
      ;;
    \?)
      echo "Invalid option: -$OPTARG" >&2
      syntax
      exit 4
      ;;
  esac
done
shift $(expr $OPTIND - 1 )
if test $# -eq 1; then
  name=`clean "${1}"`
  shift
fi 

if test $# -gt 0; then
  echo "Unexpected parameters specified: $*"
  syntax
  exit 16
fi

if [[ "${recfm}" == "FB" ]]; then
  recfm="RECFM(F,B)"
  if [[ "${lrecl}" == "" ]]; then
    lrecl="80"
  fi
elif [[ "${recfm}" == "VB" ]]; then 
  recfm="RECFM(V,B)"
  if [[ "${lrecl}" == "" ]]; then
    lrecl="137"
  fi
elif [[ "${recfm}" == "U" ]]; then
  recfm="RECFM(U)"
  if [[ "${lrecl}" == "" ]]; then
    lrecl="0"
  fi
else
  echo "Invalid record format specified. Valid options are: FB, VB or U" 
  exit 4
fi

if [[ "${lrecl}" == "80" ]]; then
  lrecl="LRECL(${lrecl})"
  blksize="BLKSIZE(3120)"
elif [[ "${lrecl}" == "137" ]]; then
  lrecl="LRECL(${lrecl})"
  blksize="BLKSIZE(1370)"
elif [[ "${lrecl}" == "0" ]]; then
  lrecl="LRECL(${lrecl})"
  blksize="BLKSIZE(32760)"
else
  lrecl="LRECL(${lrecl})"
  blksize="BLKSIZE(32760)"
fi
if [[ "${dataclass}" == "" ]]; then
  lrecl="${lrecl} ${blksize}"
fi

if [[ "${key}" != "" ]]; then
  keyoff=`echo ${key} | cut -d':' -f 1`
  keylen=`echo ${key} | cut -d':' -f 2`
fi
keyoff=`getNumber "${keyoff}"`
keylen=`getNumber "${keylen}"`

if [[ "${type}" == "PDSE" ]]; then
  type="DSNTYPE(LIBRARY,2) DSORG(PO)"
elif [[ "${type}" == "PDS" ]]; then
  type="DSNTYPE(PDS) DSORG(PO)"
elif [[ "${type}" == "SEQ" ]]; then
  if [[ "${dataclass}" == "" ]]; then
    type="DSNTYPE(BASIC) DSORG(PS)"
  else 
    type="DSNTYPE(LARGE) DSNTYPE(EXTREQ) DSORG(PS)"
  fi
elif [[ "${type}" == "KSDS" ]]; then
  if [[ "${dataclass}" == "" || "${keyoff}" == "${INVALID}" || "${keylen}" == "${INVALID}" ]]; then
    echo "You must specify a dataclass, key offset and ken length for a KSDS dataset" >&2
    syntax
    exit 4
  fi
  type="DSNTYPE(EXTREQ) RECORG(KS) KEYOFF(${keyoff}) KEYLEN(${keylen})"
  recfm=""
elif [[ "${type}" == "ESDS" ]]; then
  if [[ "${dataclass}" == "" ]]; then
    echo "You must specify a dataclass for an ESDS dataset" >&2
    syntax
    exit 4
  fi
  type="DSNTYPE(EXTREQ) RECORG(ES)"
  recfm=""
elif [[ "${type}" == "RRDS" ]]; then
  if [[ "${dataclass}" == "" ]]; then
    echo "You must specify a dataclass for an RRDS dataset" >&2
    syntax
    exit 4
  fi
  type="DSNTYPE(EXTREC) RECORG(RR)"
  recfm=""
else
  echo "Invalid dataset type specified. Valid options are: PDS,PDSE,SEQ,KSDS,ESDS,RRDS" >&2
  exit 4
fi
if [[ "${dataclass}" != "" ]]; then
  type="${type} DATACLAS(${dataclass})"
fi
if [[ "${name}" == "" ]]; then
  name=`tempname 000`   
fi
if [[ ${#name} -gt 44 ]]; then
  echo "Invalid name. Name must be less than 44 characters." >&2
  exit 4
fi
dsname="DATASET('${name}')"

size=`normalizeSize ${size} ${dataclass}`
err=/tmp/${name}.$$.err
out=/tmp/${name}.$$.out
cmd="alloc ${dsname} ${type} ${recfm} ${lrecl} ${size} NEW CATALOG"
if [[ ${verboseAllocation} -gt 0 ]]; then
  echo "${cmd}"
fi
tsocmd "${cmd}" >${out} 2>${err}
rc=$?
if [[ ${rc} -gt 0 ]]; then
  cat ${err} >&2
  cat ${out} 
else 
  if [[ ${verboseName} -gt 0 ]]; then
    echo "${name}"
  fi
  rm -f ${out} ${err}
fi
exit ${rc}
